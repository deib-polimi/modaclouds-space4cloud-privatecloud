set TIME_INT;
set VM;
set HOST;
set TIER ordered;
param RAMHost{HOST} >= 0;
param CPUCoreHost{HOST} >= 0;
param DensityHost{HOST} >= 0;
param CPUSpeedHost{HOST} >= 0;
param StorageHost{HOST} >= 0;
param CostHost{HOST, TIME_INT} >= 0;
param RAMVm{VM} >= 0;
param CPUCoreVm{VM} >= 0;
param CPUSpeedVm{VM} >= 0;
param StorageVm{VM} >= 0;
param CostVm{VM, TIME_INT} >= 0;
param ActivationValue{VM, TIME_INT} binary;
param BelongsVm{VM, TIER} binary;
param TierRatio{TIER, TIER, TIME_INT} >= 0;
var X{VM, HOST, TIME_INT} binary;
var Y{VM, HOST} binary;
var Z{HOST, TIME_INT} binary;
var W{VM, TIME_INT} binary;
var ALPHA{TIME_INT} binary;
var GAMMA{TIME_INT} binary;
var BETA{TIER, TIME_INT} >= 0 integer;
minimize Total_Cost: sum{h in HOST, t in TIME_INT} (CostHost[h, t]*Z[h, t]) + sum{v in VM, t in TIME_INT} (CostVm[v, t]*W[v, t]);
subject to C2 {v in VM, h in HOST, t in TIME_INT}: X[v, h, t] <= Y[v, h];
subject to C3_EachVmOnMaxOneHost {v in VM}: sum{h in HOST} (Y[v, h]) <= 1;
subject to C4_HostOnIfVmRunning {v in VM, h in HOST, t in TIME_INT}: X[v, h, t] <= Z[h, t];
subject to C5_VmConsideredOnlyIfRunning {v in VM, h in HOST, t in TIME_INT}: X[v, h, t] <= ActivationValue[v, t];
subject to C6_VmEitherPublicOrPrivate {v in VM, t in TIME_INT}: sum{h in HOST} (X[v, h, t]) + W[v, t] = ActivationValue[v, t];
subject to C9_TotalRam {h in HOST, t in TIME_INT}: sum{v in VM} (RAMVm[v]*X[v, h, t]) <= RAMHost[h];
subject to C10_TotalCore {h in HOST, t in TIME_INT}: sum{v in VM} (CPUCoreVm[v]*X[v, h, t]) <= CPUCoreHost[h]*DensityHost[h];
subject to C11_TotalSpeed {h in HOST, t in TIME_INT}: sum{v in VM} (CPUCoreVm[v]*CPUSpeedVm[v]*X[v, h, t]) <= CPUCoreHost[h]*CPUSpeedHost[h]*DensityHost[h];
subject to C12 {v in VM, h in HOST, t in TIME_INT}: CPUSpeedVm[v]*X[v, h, t] <= CPUSpeedHost[h];
subject to C13_TotalStorage {h in HOST, t in TIME_INT}: sum{v in VM} (StorageVm[v]*X[v, h, t]) <= StorageHost[h]*DensityHost[h];
subject to C14 {v in VM, r in TIER, t in TIME_INT}: W[v, t]*BelongsVm[v, r] <= ALPHA[t];
subject to C15 {r in TIER, t in TIME_INT}: ALPHA[t] <= sum{v in VM} (W[v, t]*BelongsVm[v, r]);
subject to C16 {r in TIER, t in TIME_INT}: BETA[r, t] = sum{v in VM} (W[v, t]*BelongsVm[v, r]);
subject to C17 {r1 in TIER, r2 in TIER, t in TIME_INT}: TierRatio[r1, r2, t]*BETA[r1, t] >= BETA[r2, t];
subject to C7 {r in TIER, t in TIME_INT}: GAMMA[t] <= sum{v in VM}sum{h in HOST} (X[v,h, t]*BelongsVm[v, r]);
subject to C8 {v in VM, r in TIER, t in TIME_INT}: GAMMA[t] >= sum{h in HOST} (X[v,h, t]*BelongsVm[v, r]);
